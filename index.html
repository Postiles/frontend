<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
.post {
	display: none; /*to be triggered by js*/
	position: absolute;
	padding: 8px;
	background: rgba(255, 255, 255, 0.8);
	border-radius: 4px;
	z-index: 0;
}
.canvas_viewport {
	overflow: hidden;
	position: relative;
}
.canvas {
	width: 3872px;
	height: 2592px;
	background-image: url(moc.jpg);
	position: absolute;
}

/*Mask*/

.canvas_mask {
	width: 100%;
	height: 100%;
	position: absolute;
	z-index: 100;
	left: 0;
	top: 0;
	background-color: rgba(0, 0, 0, 0.3);
	display: none; /*to be triggered by js*/
}
.mask_notice {
	margin-top: 5%;
	text-align: center;
	height: 88px;
	font-size: 32px;
	line-height: 44px;
	color: white;
	font-weight: bold;
	z-index: 0;
}
.post_preview {
	position: absolute;
	opacity: 0.6;
	padding: 5px;
	border: 3px dashed #FFF;
	border-radius: 4px;
	z-index: 1;
}
.post_preview_origin_spot {
	display: none;
	position: absolute;
	width: 20px;
	height: 20px;
	border-radius: 8px;
	background-color: #FFF;
	z-index: 2;
}
</style>
<script type="text/javascript" src="jquery-1.8.1.js"></script>
<script type="text/javascript">
/**

Some notice for the current demo:

The minimum unit of the grid is set to 75*50px, plus a margin of 14px and padding of 8px

TODO: implement realclick event which will not be triggered if dragging is activated

**/

var canvas_viewport, canvas;

var canvas_mouse_event = {
	mousedownCoord: null, //record the mouse position when mousedown triggered
	canvasCoord: null, //current canvas position relative to the canvas viewport
	shadowCoord: [0, 0], //current shadow (the boundary-out(boundout) effect)
	canvasAnimationCounter: null,
	canvasOutBoundAnimation: function(){ //index 0 for x and 1 for y
		canvas.css({'box-shadow': canvas_mouse_event.shadowCoord[0]/10+'px '+canvas_mouse_event.shadowCoord[1]/10+'px '+Math.sqrt(Math.pow(canvas_mouse_event.shadowCoord[0], 2)+Math.pow(canvas_mouse_event.shadowCoord[1], 2))/10+'px 0 rgba(255, 255, 255, 0.75) inset'});
	},
	currentArray: null, //an array containing all posts shown //TODO: is this really needed? anyway it is required at this moment
	newPostStartCoord: null //hold the starting point of a new post in an array with the unit of "grid unit"
};

var post_board = { //collection of utilities/functions related to the post board

	lengthConvert: {
		//convent length from "unit length" of the grid to pixel.
		widthTo: function(u) { return (u*(75+30) - 30); },
		heightTo: function(u) { return (u*(50+30) - 30); },
		xPosTo: function(u) { return (u*(75+30) + canvas.innerWidth()/2); },
		yPosTo: function(u) { return (u*(50+30) + canvas.innerHeight()/2); },
		//convent length to "unit length" of the grid from pixel. it is from the center grid points so margins and paddings are ignored.
		xPosFrom: function(px) { return ((px + 7 - canvas.innerWidth()/2)/(75+30)); },
		yPosFrom: function(px) { return ((px + 7 - canvas.innerHeight()/2)/(50+30)); }
		//widthFrom: function(px) { return Math.min(Math.round((px+30) / (75+30)), 1); },
		//heightFrom: function(px) { return Math.min(Math.round((px+30) / (50+30)), 1); },
	},
	
	renderArray: function(array) { //add post objects to the screen //NOTICE: just add, no not care the duplicate
		var i;
		canvas_mouse_event.currentArray = array;
		for (i in array) {
			array[i].x_pos_end = array[i].x_pos + array[i].width; //precalculate this two so that future intersect test will be faster
			array[i].y_pos_end = array[i].y_pos + array[i].height;
			array[i].jqDivElement = $('<div/>').appendTo(canvas);
			array[i].jqDivElement.data({parent: array[i]});
			array[i].jqDivElement.addClass('post');
			array[i].jqDivElement.css({
				'left': post_board.lengthConvert.xPosTo(array[i].x_pos) + 'px',
				'top': post_board.lengthConvert.yPosTo(array[i].y_pos) + 'px',
				'width': post_board.lengthConvert.widthTo(array[i].width) + 'px',
				'height': post_board.lengthConvert.heightTo(array[i].height) + 'px'
			});
			array[i].jqDivElement.dblclick(function(event){event.stopPropagation();}); //prevent doubleclick from triggering "creating new post"
			array[i].jqDivElement.html(array[i].content);
			array[i].jqDivElement.delay(80*i).show(200);
		}
	},
	
	clearCanvas: function() { //clear the entire canvas
		canvas.remove('.post');
		//TODO: go back to the center
	}
	
};

$(document).ready(function() { //initialize the canvas

	$(window).resize(function() { window.location.reload(); }); //prevent from resizing //later on, we still need to fix for chrome Issue 55793
	
	canvas_viewport = ($('<div/>').appendTo('#wrapper').addClass('canvas_viewport'));
	canvas = $('<div/>').appendTo(canvas_viewport);
	
	canvas_viewport.width(window.innerWidth);
	canvas_viewport.height(window.innerHeight);
	canvas_viewport.attr('unselectable','on').css('user-select', 'none').on('selectstart', false); //disable text selecting
	
	canvas.addClass('canvas');
	
	canvas_mouse_event.canvasCoord = [(canvas.parent().innerWidth() - canvas.outerWidth())/2, (canvas.parent().innerHeight() - canvas.outerHeight())/2]; //To be replaced
	
	canvas.css({'left': canvas_mouse_event.canvasCoord[0] + 'px', 'top': canvas_mouse_event.canvasCoord[1] + 'px'});
	
	canvas.mousedown(function(e) {
		canvas_mouse_event.mousedownCoord = [e.pageX, e.pageY];
		if (canvas_mouse_event.canvasAnimationCounter) {
			canvas_mouse_event.canvasAnimationCounter.stop(); //stop current animation
		}
	});
	
	canvas.mouseup(function(e) { 
		canvas_mouse_event.mousedownCoord = null;
		canvas_mouse_event.canvasCoord = [parseFloat(canvas.css('left')),parseFloat(canvas.css('top'))];
		if (canvas_mouse_event.shadowCoord[0] || canvas_mouse_event.shadowCoord[1]) {
			canvas_mouse_event.canvasAnimationCounter = $({'counter': 0, 'init': $.extend(true, [], canvas_mouse_event.shadowCoord)});
			canvas_mouse_event.canvasAnimationCounter.animate({'counter': Math.max(Math.abs(canvas_mouse_event.shadowCoord[0]),Math.abs(canvas_mouse_event.shadowCoord[1]))}, {'step': function(now){ //remove the white boundout effect little by little with jqery.animate
				if (this.init[0] < 0) { canvas_mouse_event.shadowCoord[0] = now > -this.init[0] ? 0 : this.init[0] + now; }
				else if (this.init[0] > 0) { canvas_mouse_event.shadowCoord[0] = now > this.init[0] ? 0 : this.init[0] - now; }
				if (this.init[1] < 0) { canvas_mouse_event.shadowCoord[1] = now > -this.init[1] ? 0 : this.init[1] + now; }
				else if (this.init[1] > 0) { canvas_mouse_event.shadowCoord[1] = now > this.init[1] ? 0 : this.init[1] - now; }
				canvas_mouse_event.canvasOutBoundAnimation();
			}});
		}
	});
	
	canvas.mousemove(function(e) {
		if (!canvas_mouse_event.mousedownCoord) { return; } //mouse key not down yet
		var leftTarget = e.pageX - canvas_mouse_event.mousedownCoord[0] + canvas_mouse_event.canvasCoord[0];
		var topTarget = e.pageY - canvas_mouse_event.mousedownCoord[1] + canvas_mouse_event.canvasCoord[1];
		var rightTarget = leftTarget - canvas.parent().innerWidth() + canvas.outerWidth();
		var bottomTarget = topTarget - canvas.parent().innerHeight() + canvas.outerHeight();
		canvas_mouse_event.shadowCoord[0] = 0;
		canvas_mouse_event.shadowCoord[1] = 0;
		if (leftTarget > 0) { //test left boundout(attempt to drag out of the boundary)
			canvas_mouse_event.shadowCoord[0] = leftTarget;
			leftTarget = 0;
		} else if (rightTarget < 0) { //test right boundout
			canvas_mouse_event.shadowCoord[0] = rightTarget;
			leftTarget -= rightTarget;
		}
		if (topTarget > 0) { //test top boundout
			canvas_mouse_event.shadowCoord[1] = topTarget;
			topTarget = 0;
		} else if (bottomTarget < 0) { //test bottom boundout
			canvas_mouse_event.shadowCoord[1] = bottomTarget;
			topTarget -= bottomTarget;
		}
		canvas.css({'left': leftTarget + 'px', 'top': topTarget + 'px'}); //apply the shadow boundout effect
		canvas_mouse_event.canvasOutBoundAnimation();
	});
	
	//add a mask
	var mask = $('<div/>').appendTo(canvas_viewport);
	mask.addClass('canvas_mask');
	$('<div/>').appendTo(mask).addClass('mask_notice').html('Click & Drag to add a post<br />Right click again to quit');
	canvas_viewport.data('mask', mask);
	mask.data('preview', $('<div/>').appendTo(mask).addClass('post_preview'));
	mask.data('preview_origin_spot', $('<div/>').appendTo(mask).addClass('post_preview_origin_spot'));
	mask.dblclick(function(){ mask.hide(); });
	
	//mouseevents for the mask
	mask.mousedown(function(e){ //find the closest grid point
		canvas_mouse_event.newPostStartCoord = [Math.round(post_board.lengthConvert.xPosFrom(e.pageX - canvas_mouse_event.canvasCoord[0])), Math.round(post_board.lengthConvert.yPosFrom(e.pageY - canvas_mouse_event.canvasCoord[1]))]; //record current coordinate in the unit of "grid unit" //TODO: detect if the start point is legal (if there is available space around it)
		mask.data('preview_origin_spot').css({'left': post_board.lengthConvert.xPosTo(canvas_mouse_event.newPostStartCoord[0])+canvas_mouse_event.canvasCoord[0]-17+'px', 'top':  post_board.lengthConvert.yPosTo(canvas_mouse_event.newPostStartCoord[1])+canvas_mouse_event.canvasCoord[1]-17+'px'}).show();
	});

	mask.mousemove(function(e){ //mouse key not down yet
		if (!canvas_mouse_event.newPostStartCoord) { return; }
		var current = [post_board.lengthConvert.xPosFrom(e.pageX - canvas_mouse_event.canvasCoord[0]), post_board.lengthConvert.yPosFrom(e.pageY - canvas_mouse_event.canvasCoord[1])];
		var delta = [0, 0];
		var end = [0, 0];
		var i;
		for (i = 0; i < 2; i++) {
			delta[i] = current[i] - canvas_mouse_event.newPostStartCoord[i]; //calculate the expected width/height in the unit of "grid unit"
			if (delta[i] < 0) { //if in doubt, use brute force
				if (delta[i] > -1) { delta[i] = -1; } else { delta[i] = Math.round(delta[i]); }
				current[i] = canvas_mouse_event.newPostStartCoord[i] + delta[i];
				end[i] = canvas_mouse_event.newPostStartCoord[i];
			} else {
				if (delta[i] < 1) { delta[i] = 1; } else { delta[i] = Math.round(delta[i]); }
				current[i] = canvas_mouse_event.newPostStartCoord[i];
				end[i] = canvas_mouse_event.newPostStartCoord[i] + delta[i];
			}
		}
		//now "current" saves the smaller value and "end" saves the larger one
		//check if available
		var intersect = false;
		for (i in canvas_mouse_event.currentArray) {
			//from http://stackoverflow.com/questions/2752349/fast-rectangle-to-rectangle-intersection
			if(!(current[0] >= canvas_mouse_event.currentArray[i].x_pos_end || end[0] <= canvas_mouse_event.currentArray[i].x_pos || current[1] >=canvas_mouse_event.currentArray[i].y_pos_end || end[1] <= canvas_mouse_event.currentArray[i].y_pos)) { 
				intersect = true;
				break;
			}
		}
		//draw on the canvas
		var preview = mask.data('preview');
		preview.css({
			'left': post_board.lengthConvert.xPosTo(current[0]) + canvas_mouse_event.canvasCoord[0] + 'px',
			'top': post_board.lengthConvert.yPosTo(current[1]) + canvas_mouse_event.canvasCoord[1] + 'px',
			'width': post_board.lengthConvert.widthTo(Math.abs(delta[0])) + 'px',
			'height': post_board.lengthConvert.heightTo(Math.abs(delta[1])) + 'px',
			'background-color': intersect ? '#F00' : '#0F0'
		});
		preview.show();
		mask.data('legal', !intersect);
	});
	
	mask.mouseup(function(e){
		canvas_mouse_event.newPostStartCoord = null;
		if (!mask.data('legal')) {
			mask.data('preview').hide(); return;
		}
		mask.data('legal', false);
	});
	
	//activated double click event for creating new boxes
	canvas.dblclick(function(){
		canvas_viewport.data('mask').show();
	});
	
});

/****
Sections below are just for testing
****/

var post_board_demo = { //this is demo JSON demonstrating some data fetched from the server
	posts: [
		{ id: 128, x_pos: -1, y_pos: -3, width: 2, height: 2, content: '<b style="font-size: 20px">You can drag the canvas till you reach the boundary</b>' }, //each one stand for a post
		{ id: 111, x_pos: -1, y_pos: -1, width: 2, height: 1, content: '<font color="#990000">All code is in this HTML</font>' },
		{ id: 198, x_pos: -2, y_pos: -2, width: 1, height: 2, content: "dummy content for block 3" },
		{ id: 256, x_pos: 1, y_pos: -4, width: 2, height: 2, content: "dummy content for block 4" },
		{ id: 280, x_pos: 0, y_pos: 0, width: 1, height: 3, content: "dummy content for block 5" },
		{ id: 310, x_pos: -2, y_pos: 2, width: 2, height: 2, content: "dummy content for block 6" },
		{ id: 317, x_pos: 1, y_pos: 0, width: 3, height: 3, content: '<b style="font-size: 24px; color: #C00">You can try to double click on blank places</b>' },
		{ id: 319, x_pos: -5, y_pos: -3, width: 3, height: 2, content: "dummy content for block 8" }
	]
}

$(window).load(function(){  
	setTimeout(function(){post_board.renderArray(post_board_demo.posts);},600)
});

</script>
<style type="text/css">
html, body, wrapper {
	padding: 0;
	margin: 0;
	border: 0 none;
}
</style>
</head>
<body>
	<div id="wrapper">
	</div>
</body>
</html>